<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Rush V2</title>
    <style>
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #050505;
            font-family: sans-serif;
            touch-action: none;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            padding: 20px;
        }
        #score-board {
            color: #fff; font-size: 24px; font-weight: 800;
            text-shadow: 0 0 10px #0ff;
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            pointer-events: auto;
            z-index: 100;
            transition: opacity 0.3s;
        }
        h1 {
            color: #f0f; font-size: 40px; margin: 0 0 10px 0;
            text-shadow: 2px 2px #0ff; font-style: italic;
        }
        button {
            background: linear-gradient(45deg, #f0f, #0ff);
            border: none; padding: 20px 50px;
            color: white; font-size: 20px; font-weight: bold;
            border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            margin-top: 20px;
        }
        button:active { transform: scale(0.95); opacity: 0.8; }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">SCORE: 0</div>
    </div>

    <div id="start-screen">
        <h1>NEON RUSH</h1>
        <p style="color: #ddd;">Drag Left/Right to Steer</p>
        <button id="start-btn">START ENGINE</button>
    </div>

    <script>
        // Error trapping for mobile
        window.onerror = function(msg, url, line) {
            alert("Game Error: " + msg + "\nLine: " + line);
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const scoreEl = document.getElementById('score-board');

        // Game State
        let isPlaying = false;
        let score = 0;
        let gameSpeed = 5;
        let lastTime = 0;
        let animationId = null;

        // Dimensions
        let width = window.innerWidth;
        let height = window.innerHeight;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // Game Objects
        // We define player structure but set X/Y in resetGame
        const player = { x: 0, y: 0, w: 50, h: 80, color: '#0ff' };
        let obstacles = [];
        let particles = [];
        let roadOffset = 0;

        // Input Handling
        let touchX = null;

        // Touch
        document.addEventListener('touchstart', (e) => {
            touchX = e.touches[0].clientX;
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isPlaying) return;
            e.preventDefault();
            const currentX = e.touches[0].clientX;
            const diff = currentX - touchX;
            player.x += diff * 1.5;
            touchX = currentX;
            clampPlayer();
        }, { passive: false });

        // Mouse (for testing)
        let isDragging = false;
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            touchX = e.clientX;
        });
        document.addEventListener('mousemove', (e) => {
            if (!isPlaying || !isDragging) return;
            const diff = e.clientX - touchX;
            player.x += diff;
            touchX = e.clientX;
            clampPlayer();
        });
        document.addEventListener('mouseup', () => isDragging = false);

        function clampPlayer() {
            if (player.x < player.w/2) player.x = player.w/2;
            if (player.x > width - player.w/2) player.x = width - player.w/2;
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0, color: color
                });
            }
        }

        function update(dt) {
            gameSpeed += 0.005; // Acceleration
            roadOffset = (roadOffset + gameSpeed) % 60;
            
            // Spawn
            if (Math.random() < 0.02 + (score * 0.00005)) {
                let type = Math.random() > 0.8 ? 'coin' : 'enemy';
                let size = type === 'coin' ? 30 : 60;
                obstacles.push({
                    x: Math.random() * (width - size) + size/2,
                    y: -100,
                    w: size, h: size,
                    type: type, active: true
                });
            }

            // Move Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                ob.y += gameSpeed;

                // Collision
                if (ob.active &&
                    Math.abs(player.x - ob.x) < (player.w/2 + ob.w/2) &&
                    Math.abs(player.y - ob.y) < (player.h/2 + ob.h/2)) {
                    
                    if (ob.type === 'enemy') {
                        gameOver();
                    } else {
                        score += 100;
                        createParticles(ob.x, ob.y, '#ff0');
                        ob.active = false;
                    }
                }

                if (ob.y > height + 100) obstacles.splice(i, 1);
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            }
            
            scoreEl.innerText = "SCORE: " + Math.floor(score);
        }

        function draw() {
            // Background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);

            // Grid / Road
            ctx.strokeStyle = '#f0f';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            
            // Horizon line
            let horizon = height; 
            
            // Moving horizontal lines
            ctx.beginPath();
            for(let y = roadOffset; y < height; y += 60) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();

            // Perspective lines
            ctx.beginPath();
            let cx = width / 2;
            for(let i = -5; i <= 5; i++) {
                let x = cx + (i * 150);
                ctx.moveTo(x, 0);
                ctx.lineTo(cx + (i * 400), height);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;

            // Player
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - player.h/2);
            ctx.lineTo(player.x - player.w/2, player.y + player.h/2);
            ctx.lineTo(player.x + player.w/2, player.y + player.h/2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Obstacles
            obstacles.forEach(ob => {
                if (!ob.active) return;
                ctx.shadowBlur = 10;
                if (ob.type === 'enemy') {
                    ctx.fillStyle = '#f04';
                    ctx.shadowColor = '#f04';
                    ctx.fillRect(ob.x - ob.w/2, ob.y - ob.h/2, ob.w, ob.h);
                } else {
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#ff0';
                    ctx.beginPath();
                    ctx.arc(ob.x, ob.y, ob.w/2,
